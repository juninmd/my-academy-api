generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Exercises {
  id       Int        @id @default(autoincrement())
  name     String     @unique
  image    String
  tips     String
  mistakes String
  workouts Workouts[]
}

model Methods {
  id          Int        @id @default(autoincrement())
  name        String
  description String
  workouts    Workouts[]
}

model Workouts {
  id               Int             @id @default(autoincrement())
  exerciseId       Int
  description      String
  workoutsGroupsId Int
  methodId         Int?
  workoutBlocks    WorkoutBlock[] // Adiciona a relação com WorkoutBlock
  workoutSeries    WorkoutSeries[] // Mantém o campo, mas sem a anotação @deprecated
  exercise         Exercises       @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  method           Methods?        @relation(fields: [methodId], references: [id], onDelete: Cascade)
  workoutGroup     WorkoutsGroups  @relation(fields: [workoutsGroupsId], references: [id], onDelete: Cascade)

  @@unique([workoutsGroupsId, exerciseId])
}

model WorkoutsGroups {
  id              Int               @id @default(autoincrement())
  name            String
  image           String
  observations    String? // New field for observations
  userId          String // User who owns this workout group (student)
  personalId      Int? // Personal who created/modified this workout group
  WorkoutSessions WorkoutSessions[]
  workouts        Workouts[]
  user            Users             @relation(fields: [userId], references: [id], onDelete: Cascade)
  personal        Personals?        @relation(fields: [personalId], references: [id]) // Optional relation to personal

  @@unique([userId, name])
}

enum Role {
  STUDENT
  PERSONAL
  ACADEMY_OWNER
}

model Users {
  id                String              @id
  name              String
  email             String
  photoUrl          String              @default("https://w7.pngwing.com/pngs/620/837/png-transparent-bodybuilding-drawing-bodybuilding-physical-fitness-logo-monochrome-thumbnail.png")
  telegramId        String?
  role              Role                @default(STUDENT) // New field for user role
  workoutsGroups    WorkoutsGroups[]
  Personals         Personals[]         @relation("personal")
  Students          Personals[]         @relation("student")
  PhysicalAssessments PhysicalAssessment[]
  NotificationsSent Notifications[]     @relation("sender")
  NotificationsReceived Notifications[] @relation("receiver")
  ClassBookings     ClassBooking[]
  fcmToken          String? // New field for Firebase Cloud Messaging token
  subscriptions     Subscription[]
  physicalAssessmentSchedules PhysicalAssessmentSchedule[]
}

model WorkoutBlock {
  id            Int           @id @default(autoincrement())
  workoutId     Int
  order         Int // Ordem do bloco dentro de um treino
  workout       Workouts      @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  workoutSeries WorkoutSeries[]
}

model WorkoutSeries {
  id             Int         @id @default(autoincrement())
  workoutId      Int
  workoutBlockId Int? // Chave estrangeira para WorkoutBlock
  repetitions    Int         @default(15)
  weight         Int?        @default(10)
  rest           Int?        @default(60)
  workout        Workouts    @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  workoutBlock   WorkoutBlock? @relation(fields: [workoutBlockId], references: [id], onDelete: Cascade) // Relação com WorkoutBlock
}

// New model for Subscriptions/Payments
model Subscription {
  id          Int      @id @default(autoincrement())
  userId      String
  startDate   DateTime @default(now()) @db.Date
  endDate     DateTime?
  status      String   @default("ACTIVE") // e.g., "ACTIVE", "INACTIVE", "PENDING", "CANCELLED"
  amount      Float
  paymentDate DateTime @default(now()) @db.Date
  user        Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WorkoutSessions {
  id             Int            @id @default(autoincrement())
  date           DateTime       @default(now()) @db.Date
  workoutGroupId Int
  isCompleted    Boolean        @default(false) // New field: indicates if the workout session was completed
  completedAt    DateTime?      // New field: timestamp of completion
  workoutsGroups WorkoutsGroups @relation(fields: [workoutGroupId], references: [id], onDelete: Cascade)
  notification   Notifications? // New field: link to a notification if sent
}

model Personals {
  id                    Int                     @id @default(autoincrement())
  StudentUser           Users                   @relation("student", fields: [studentUserId], references: [id], onDelete: Cascade)
  studentUserId         String
  PersonalUser          Users                   @relation("personal", fields: [personalUserId], references: [id], onDelete: Cascade)
  personalUserId        String
  PersonalClassSchedule PersonalClassSchedule[]
  WorkoutsGroups        WorkoutsGroups[] // Personal can manage workout groups
  physicalAssessmentSchedules PhysicalAssessmentSchedule[]

  @@unique([studentUserId, personalUserId])
}

model PersonalClassSchedule {
  id          Int       @id @default(autoincrement())
  dayOfWeek   Int // Dia da semana (ex: "Monday", "Tuesday", etc.)
  time        String // Horário da aula (ex: "18:30", "07:00")
  status      String @default("scheduled") // New field: "scheduled", "completed", "cancelled"
  personalsId Int // Chave estrangeira para o modelo Personals
  personals   Personals @relation(fields: [personalsId], references: [id], onDelete: Cascade)
  bookings    ClassBooking[]
}

// New model for Physical Assessments
model PhysicalAssessment {
  id                  Int       @id @default(autoincrement())
  userId              String
  date                DateTime  @default(now()) @db.Date
  weight              Float?
  height              Float?
  bodyFatPercentage   Float?
  muscleMassPercentage Float?
  tricepsSkinfold      Float?
  bicepsSkinfold       Float?
  subscapularSkinfold  Float?
  suprailiacSkinfold   Float?
  midaxillarySkinfold  Float?
  pectoralSkinfold     Float?
  thighSkinfold        Float?
  observations        String?
  user                Users     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// New model for Notifications
model Notifications {
  id                Int             @id @default(autoincrement())
  senderId          String
  receiverId        String
  message           String
  type              String // e.g., "workout_completed", "class_reminder", "new_assessment"
  readStatus        Boolean         @default(false)
  timestamp         DateTime        @default(now())
  workoutSessionId  Int?            @unique // Optional: link to a specific workout session
  sender            Users           @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver          Users           @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  workoutSession    WorkoutSessions? @relation(fields: [workoutSessionId], references: [id])
}

// New model for Class Bookings
model ClassBooking {
  id                      Int                   @id @default(autoincrement())
  personalClassScheduleId Int
  studentId               String
  bookingDate             DateTime              @default(now()) @db.Date
  status                  String                @default("booked") // "booked", "confirmed", "cancelled", "completed"
  personalClassSchedule   PersonalClassSchedule @relation(fields: [personalClassScheduleId], references: [id], onDelete: Cascade)
  student                 Users                 @relation(fields: [studentId], references: [id], onDelete: Cascade)
}

// New model for Physical Assessment Schedules
model PhysicalAssessmentSchedule {
  id         Int      @id @default(autoincrement())
  date       DateTime @db.Date
  time       String
  userId     String
  personalId Int
  status     String   @default("scheduled") // e.g., "scheduled", "completed", "cancelled"
  user       Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
  personal   Personals @relation(fields: [personalId], references: [id], onDelete: Cascade)
}
