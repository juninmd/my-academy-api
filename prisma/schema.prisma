generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Exercises {
  id       Int        @id @default(autoincrement())
  name     String     @unique
  image    String
  tips     String
  mistakes String
  workouts Workouts[]
}

model Methods {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  description String
  workouts    Workouts[]
}

model WorkoutsBlocks {
  id             Int            @id @default(autoincrement())
  workoutGroupId Int // Referencia WorkoutGroup
  order          Int // Ordem do bloco dentro de um treino
  workoutGroup   WorkoutsGroups @relation(fields: [workoutGroupId], references: [id], onDelete: Cascade) // Relação com WorkoutGroup
  workouts       Workouts[] // Relação com Workout (ajustado conforme feedback)
}

model Workouts {
  id               Int             @id @default(autoincrement())
  exerciseId       Int
  description      String
  workoutsBlocksId Int
  methodId         Int?
  workoutSeries    WorkoutSeries[] // Mantém o campo, mas sem a anotação @deprecated
  exercise         Exercises       @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  method           Methods?        @relation(fields: [methodId], references: [id], onDelete: Cascade)
  workoutBlock     WorkoutsBlocks  @relation(fields: [workoutsBlocksId], references: [id], onDelete: Cascade)

  @@unique([workoutsBlocksId, exerciseId])
}

model WorkoutsGroups {
  id                  Int                   @id @default(autoincrement())
  name                String
  observations        String? // New field for observations
  userId              String // User who owns this workout group (student)
  personalId          Int? // Personal who created/modified this workout group (referencia PersonalStudent)
  workoutGroupSession WorkoutGroupSession[] // Relação com WorkoutSession
  workoutsBlocks       WorkoutsBlocks[] // Relação com WorkoutBlock (ajustado conforme feedback)
  user                Users                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
}

model WorkoutSeries {
  id          Int      @id @default(autoincrement())
  workoutId   Int // Referencia Workout
  repetitions Int      @default(15)
  weight      Int?     @default(10)
  rest        Int?     @default(60)
  workout     Workouts @relation(fields: [workoutId], references: [id], onDelete: Cascade) // Relação com Workout
}

model UserRole {
  userId   String
  roleId   Int
  user     Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
  roleUser RoleUser @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

// New model for Subscriptions/Payments
model Subscription {
  id          Int       @id @default(autoincrement())
  userId      String
  startDate   DateTime  @default(now()) @db.Date
  endDate     DateTime?
  status      String    @default("ACTIVE") // e.g., "ACTIVE", "INACTIVE", "PENDING", "CANCELLED"
  amount      Float
  paymentDate DateTime  @default(now()) @db.Date
  user        Users     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Users {
  id                    String               @id
  name                  String
  email                 String
  photoUrl              String               @default("https://w7.pngwing.com/pngs/620/837/png-transparent-bodybuilding-drawing-bodybuilding-physical-fitness-logo-monochrome-thumbnail.png")
  telegramId            String?
  roles                 UserRole[] // Relação muitos-para-muitos com Role
  workoutsGroups        WorkoutsGroups[]
  PhysicalAssessments   PhysicalAssessment[]
  NotificationsSent     Notifications[]      @relation("sender")
  NotificationsReceived Notifications[]      @relation("receiver")
  ClassBookings         ClassBooking[]
  fcmToken              String? // New field for Firebase Cloud Messaging token
  subscriptions         Subscription[] // Referencia Subscription
}

model WorkoutGroupSession {
  id             Int            @id @default(autoincrement())
  workoutGroupId Int // Referencia WorkoutGroup
  isCompleted    Boolean        @default(false) // New field: indicates if the workout session was completed
  completedAt    DateTime? // New field: timestamp of completion
  workoutsGroups WorkoutsGroups @relation(fields: [workoutGroupId], references: [id], onDelete: Cascade)
  notification   Notifications? // New field: link to a notification if sent
}

model Personals {
  id                          Int                          @id @default(autoincrement())
  studentUserId               String
  personalUserId              String
  PersonalClassSchedule       PersonalClassSchedule[]
  physicalAssessmentSchedules PhysicalAssessmentSchedule[]
  personalTrainingPlans       PersonalTrainingPlan[]

  @@unique([studentUserId, personalUserId])
}

model PersonalClassSchedule {
  id                     Int                   @id @default(autoincrement())
  dayOfWeek              Int // Dia da semana (ex: "Monday", "Tuesday", etc.)
  time                   String // Horário da aula (ex: "18:30", "07:00")
  status                 String                @default("scheduled") // New field: "scheduled", "completed", "cancelled"
  personalsId            Int // Chave estrangeira para o modelo Personals
  personals              Personals             @relation(fields: [personalsId], references: [id], onDelete: Cascade)
  bookings               ClassBooking[]
  personalTrainingPlan   PersonalTrainingPlan? @relation(fields: [personalTrainingPlanId], references: [id])
  personalTrainingPlanId Int?
}

// New model for Physical Assessments
model PhysicalAssessment {
  id                   Int      @id @default(autoincrement())
  userId               String
  date                 DateTime @default(now()) @db.Date
  weight               Float?
  height               Float?
  bodyFatPercentage    Float?
  muscleMassPercentage Float?
  tricepsSkinfold      Float?
  bicepsSkinfold       Float?
  subscapularSkinfold  Float?
  suprailiacSkinfold   Float?
  midaxillarySkinfold  Float?
  pectoralSkinfold     Float?
  thighSkinfold        Float?
  observations         String?
  user                 Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// New model for Notifications
model Notifications {
  id                    Int                  @id @default(autoincrement())
  senderId              String
  receiverId            String
  message               String
  type                  String // e.g., "workout_completed", "class_reminder", "new_assessment"
  readStatus            Boolean              @default(false)
  timestamp             DateTime             @default(now())
  workoutGroupSessionId Int?                 @unique // Optional: link to a specific workout session
  sender                Users                @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver              Users                @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  workoutGroupSession   WorkoutGroupSession? @relation(fields: [workoutGroupSessionId], references: [id]) // Referencia WorkoutSession
}

// New model for Class Bookings
model ClassBooking {
  id                      Int                   @id @default(autoincrement())
  personalClassScheduleId Int
  studentId               String
  bookingDate             DateTime              @default(now()) @db.Date
  status                  String                @default("booked") // "booked", "confirmed", "cancelled", "completed"
  isRescheduled           Boolean               @default(false) // New field: indicates if this is a rescheduled class
  originalClassBookingId  Int? // New field: ID of the original class booking if this is a reschedule
  originalClassBooking    ClassBooking?         @relation("RescheduledClass", fields: [originalClassBookingId], references: [id])
  rescheduledClasses      ClassBooking[]        @relation("RescheduledClass")
  personalClassSchedule   PersonalClassSchedule @relation(fields: [personalClassScheduleId], references: [id], onDelete: Cascade)
  student                 Users                 @relation(fields: [studentId], references: [id], onDelete: Cascade)
}

// New model for Physical Assessment Schedules
model PhysicalAssessmentSchedule {
  id         Int       @id @default(autoincrement())
  date       DateTime  @db.Date
  time       String
  userId     String
  personalId Int
  status     String    @default("scheduled") // e.g., "scheduled", "completed", "cancelled"
  personal   Personals @relation(fields: [personalId], references: [id], onDelete: Cascade)
}

// New model for Personal Training Plans
model PersonalTrainingPlan {
  id                       Int                     @id @default(autoincrement())
  personalId               Int
  startDate                DateTime                @db.Date
  endDate                  DateTime?               @db.Date
  sessionsPerWeek          Int
  reschedulesPerMonthLimit Int                     @default(0) // New field: limit for class reschedules per month
  pricePerSession          Float? // New field for price per session
  billingType              String?                 @default("separate") // New field: "included" or "separate"
  status                   String                  @default("active") // e.g., "active", "paused", "completed", "cancelled"
  personal                 Personals               @relation(fields: [personalId], references: [id], onDelete: Cascade)
  classSchedules           PersonalClassSchedule[] // Relação com as aulas agendadas
}

model MotivationalPhrases {
  id          Int      @id @default(autoincrement())
  title       String // Título em negrito, ex: "Continue Superando Seus Limites!"
  description String // Descrição da frase motivadora
  isActive    Boolean  @default(true) // Para ativar/desativar frases
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

enum RoleName {
  STUDENT
  PERSONAL
  ACADEMY_OWNER
}

model RoleUser {
  id    Int        @id @default(autoincrement())
  name  RoleName   @unique
  users UserRole[]
}

// Adicione este bloco generator
generator erd {
  provider = "prisma-erd-generator"
  output   = "./ERD.svg"
}
